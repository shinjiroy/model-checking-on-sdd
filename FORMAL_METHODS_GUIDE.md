# Spec Kit 形式手法統合ガイド

---

## 目次

1. [概要](#概要)
2. [核心原則](#核心原則)
3. [形式検証を使うタイミング](#形式検証を使うタイミング)
4. [ワークフロー統合](#ワークフロー統合)
5. [コマンドリファレンス](#コマンドリファレンス)
6. [ベストプラクティス](#ベストプラクティス)
7. [よくある落とし穴](#よくある落とし穴)
8. [チームガイドライン](#チームガイドライン)
9. [トラブルシューティング](#トラブルシューティング)
10. [例](#例)

---

## 概要

このガイドは、Alloyを使った形式検証をSpec Kitワークフローに統合する方法を説明します。形式検証により、実装前に仕様について数学的にプロパティを証明し、設計上の欠陥を早期に発見できます。

### 形式検証とは?

形式検証は数学的モデルを使用して、システム設計が特定のプロパティを満たすことを証明します。「仕様のユニットテスト」と考えてください - コード記述前に設計が健全であることを検証します。

### なぜAlloy?

私たちは**Alloy**のみを使用します。理由:

- **Webアプリケーション向き**: ユーザー、商品、注文、関係性のモデリングが自然
- **視覚的フィードバック**: 反例がグラフとして表示(理解しやすい)
- **適度な学習曲線**: 一階述語論理 + 関係論理
- **実用的スコープ**: APIレベルとビジネスロジック検証に適している
- **単一ツールの習得**: 多数のツールを浅く知るより、1つのツールを深く理解する方が良い

### 主な利点

- ✅ コーディング前に設計上の欠陥を発見
- ✅ 重要なプロパティを証明(二重決済なし、在庫整合性など)
- ✅ 本番バグを削減
- ✅ 複雑なロジックへのチームの信頼を構築
- ✅ システム保証を形式的に文書化

---

## 核心原則

### 1. 1つのSpec = 1つのAlloyモデル

**ルール**: 各仕様ディレクトリは**ちょうど1つ**の`.als`ファイルを持つべきです。

```
✅ 正しい:
specs/001-purchase-flow/
├── spec.md
├── plan.md
└── formal/
    └── purchase.als          # 単一モデルファイル

❌ 間違い:
specs/001-purchase-flow/
└── formal/
    ├── purchase.als
    ├── inventory.als          # 複数モデル = specが大きすぎる
    └── payment.als
```

**理由は?**

- 明確なトレーサビリティを維持(spec.md ↔ purchase.als)
- Alloyは単一ファイルの世界モデル用に設計されている
- レビューとメンテナンスが簡略化
- specが大きすぎる場合のシグナルとして機能

**複数モデルが必要に見えたら:**

1. **まず**、`spec.md`を見直す - 複数の独立した機能をカバーしているか?
2. **もしそうなら**、仕様を別々の機能に分割
3. **もしそうでなければ**、ドメインが本質的に複雑 - なぜ1つのモデルで許容されるか文書化

### 2. 形式検証はオプショナルかつ補完的

**ルール**: 形式検証は標準Spec Kitワークフローをブロックまたは置き換えません。

- `spec.md`は自然言語での真実の源のまま
- 形式検証は重要な機能に対する追加の確信を提供
- チームはどの機能に形式検証が必要か選択できる
- `formal/`ディレクトリは自己完結かつ独立

### 3. 既存ファイルの変更なし

**ルール**: 形式検証ツールは`spec.md`、`plan.md`、`tasks.md`、その他既存のSpec Kitファイルを変更しません。

すべての形式検証成果物は`formal/`サブディレクトリ内に存在:

```
specs/{FEATURE_NAME}/
├── spec.md                   # ✅ 形式ツールにより変更されない
├── plan.md                   # ✅ 形式ツールにより変更されない
├── tasks.md                  # ✅ 形式ツールにより変更されない
└── formal/                   # ✅ すべての形式作業はここに隔離
    ├── {feature}.als
    ├── properties.md
    ├── guide.md
    └── verification-log.md
```

### 4. シンプルに始め、反復する

**ルール**: 基本的なモデルと小さなスコープから始め、反復的に洗練します。

**初回検証:**

- シンプルなドメインモデル(コアエンティティのみ)
- 基本プロパティ(明白な不変条件)
- 小さなスコープ(`for 3`)
- 高速フィードバックループ

**初回成功後:**

- 徐々に複雑さを追加
- スコープを増やす(`for 5`、`for 7`)
- より洗練されたプロパティを追加
- 反例に基づいて洗練

---

## 形式検証を使うタイミング

### 推奨される場合

✅ **金融操作**

- 決済処理
- 返金とキャンセル
- 残高計算
- トランザクションログ

✅ **在庫管理**

- 在庫整合性
- 並行購入処理
- 予約システム
- 在庫レベル制約

✅ **認証と認可**

- 権限チェック
- ロールベースアクセス制御
- セッション管理
- 認証フローでの状態遷移

✅ **複雑な状態機械**

- 注文ステータスワークフロー(保留中→支払済→発送済)
- ユーザー登録フロー
- ロールバック付き複数ステッププロセス

✅ **データ整合性要件**

- 参照整合性
- 一意性制約
- 関係性の濃度
- ビジネスルールの強制

### 推奨されない場合

❌ **単純なCRUD操作**

- 複雑なロジックのない基本的な作成、読み取り、更新、削除
- 些細な検証

❌ **UI/プレゼンテーションロジック**

- 表示フォーマット
- ビューレンダリング
- クライアント側のみの機能

❌ **パフォーマンス最適化**

- キャッシング戦略
- クエリ最適化
- 負荷分散

❌ **外部サービス統合**

- サードパーティAPI呼び出し(外部システムをモデル化できない)
- ネットワーク信頼性の問題

### 判断フレームワーク

以下の質問に答えてください:

1. **この機能は安全性が重要か?**  
   (誤動作が金銭的損失、データ破損、セキュリティ侵害を引き起こす)
   → **はい** = 形式検証を使用

2. **複雑な状態遷移があるか?**  
   (複数の状態、複雑な遷移ルール)
   → **はい** = 形式検証を使用

3. **微妙な並行性の問題があるか?**  
   (複数のユーザー/プロセスが共有リソースにアクセス)
   → **はい** = 形式検証を使用

4. **ビジネスロジックが非自明か?**  
   (複雑なルール、エッジケース、相互に関連した制約)
   → **はい** = 形式検証を使用

5. **短命またはクイックプロトタイプか?**  
   → **いいえ** = 形式検証をスキップ(コストに見合わない)

---

## ワークフロー統合

### 標準Spec Kitワークフロー

```
1. /speckit.constitution  → プロジェクト原則を定義
2. /speckit.specify       → 自然言語仕様を作成
3. /speckit.plan          → 技術設計を生成
4. /speckit.tasks         → 実装タスクに分解
5. [実装]                 → コードを書く
```

### 形式検証を含む拡張ワークフロー

```
1. /speckit.constitution  → プロジェクト原則を定義
2. /speckit.specify       → 自然言語仕様を作成
3. /speckit.plan          → 技術設計を生成

   [判断ポイント: この機能は形式検証が必要か?]
   
   もし必要なら:
   4a. /speckit.formalize → Alloy形式モデルを生成
   4b. [手動] 検証       → Alloy Analyzer(GUI)を実行
   4c. /speckit.verify   → 検証結果を文書化
   4d. [反復] 修正       → 失敗があれば、修正して再検証
   
   もし不要なら:
   4. [形式検証をスキップ]

5. /speckit.tasks         → 実装タスクに分解
6. [実装]                 → 設計への確信を持ってコードを書く
```

### 典型的な反復パターン

形式検証を必要とする機能の場合:

```
反復1:
- /speckit.formalize → 初期モデルを生成
- スコープ3で検証   → 高速チェック
- ❌ 失敗発見       → 反例をレビュー
- モデルを修正      → .alsファイルを更新
- 再検証            → 再度チェック

反復2:
- ✅ スコープ3ですべて合格
- スコープ5で検証   → より徹底的
- ❌ 新しい失敗     → エッジケース発見
- spec.mdを更新    → 要件を明確化
- /speckit.formalize → モデルを再生成
- 再検証            → 再度チェック

反復3:
- ✅ スコープ5ですべて合格
- /speckit.verify   → 結果を文書化
- /speckit.tasksへ進む
```

**重要な洞察**: 反復を期待してください。失敗を発見することが成功です - 早期に問題を捉えたということです!

---

## コマンドリファレンス

### `/speckit.formalize`

**目的**: `spec.md`から形式仕様を生成

**使い方**:

```
/speckit.formalize
```

**実行内容**:

1. `spec.md`と`plan.md`を読み込む
2. エンティティ、関係性、操作を特定
3. `formal/{feature}.als`(Alloyモデル)を生成
4. `formal/properties.md`(検証チェックリスト)を生成
5. `formal/guide.md`(チーム向け手順)を生成

**出力ファイル**:

- `specs/{FEATURE_NAME}/formal/{feature}.als`
- `specs/{FEATURE_NAME}/formal/properties.md`
- `specs/{FEATURE_NAME}/formal/guide.md`

**使用タイミング**:

- `/speckit.specify`と`/speckit.plan`が完了した後
- 形式検証が必要と判断した時
- 実装開始前

**ヒント**:

- `spec.md`が完全でレビュー済みであることを確認
- 生成されたモデルの正確性をレビュー
- モデルが意図を捉えていなければ反復を躊躇しない

---

### `/speckit.verify`

**目的**: 形式検証結果を文書化

**使い方**:

```
/speckit.verify
```

**実行内容**:

1. ユーザーに手動Alloy Analyzer検証を案内
2. ユーザーから検証結果を収集
3. `formal/properties.md`を合格/不合格ステータスで更新
4. `formal/verification-log.md`にセッション詳細を追記
5. 失敗したプロパティに対する修正案を提案

**前提条件**:

- `formal/{feature}.als`が存在する(`/speckit.formalize`を先に実行)
- ユーザーがAlloy Analyzerをインストール済み
- ユーザーがAlloy Analyzerで手動検証を実行済み

**ワークフロー**:

1. コマンドがユーザーにAlloy Analyzerを開くよう促す
2. ユーザーがAlloy Analyzerで`check`コマンドを実行
3. ユーザーが結果をコマンドに報告
4. コマンドがすべてを文書化
5. コマンドが失敗に対する修正を提案

**使用タイミング**:

- Alloy Analyzerで検証を実行した後
- 検証結果を文書化するため
- 失敗を修正するための提案を得るため
- チームに検証ステータスを更新するため

**ヒント**:

- コマンドに文書化を依頼する前に検証を実行
- プロパティが失敗した場合は反例の説明を用意
- 各検証反復後にこれを使用

---

## ベストプラクティス

### モデル開発

#### 1. ドメインモデルから始める

```alloy
// 最初にエンティティを定義
sig User { }
sig Product { }
sig Order { }

// 徐々に属性を追加
sig User {
    email: one String,
    balance: one Int
}
```

#### 2. 制約を段階的に追加

```alloy
// 基本的なファクトから開始
fact ValidBalance {
    all u: User | u.balance >= 0
}

// 必要に応じてさらに追加
fact UniqueEmails {
    all disj u1, u2: User | u1.email != u2.email
}
```

#### 3. 述語をシンプルに保つ

```alloy
// ✅ 良い: シンプルで焦点を絞った述語
pred canPurchase[u: User, p: Product] {
    u.balance >= p.price
    p.stock > 0
}

// ❌ 悪い: 複雑すぎて検証が困難
pred purchase[u: User, p: Product, o: Order, ...] {
    // 50行の複雑なロジック
}
```

#### 4. 明確なアサーションを書く

```alloy
// ✅ 良い: 何を検証しているか明確
assert NoNegativeBalance {
    all u: User | u.balance >= 0
}

// ❌ 悪い: 意図が不明確
assert UserProperty {
    all u: User | some condition
}
```

### 検証戦略

#### 1. 適切なスコープを使用

| スコープ     | 用途                           | 時間       | 確信度   |
| ------------ | ------------------------------ | ---------- | -------- |
| `for 3`      | 初回テスト、高速フィードバック | 数秒       | 低       |
| `for 5`      | 標準検証                       | 数秒〜数分 | 中       |
| `for 7`      | 徹底的な検証                   | 数分       | 高       |
| `for 10以上` | 重要機能のみ                   | 遅い可能性 | 非常に高 |

**推奨**: `for 3`から開始、`for 5`で検証、必要な場合のみ増加。

#### 2. 段階的に検証

```
ステップ1: 基本構造
- シグネチャを定義
- `pred show { }` for 3 を実行
- インスタンスが妥当であることを確認

ステップ2: 一度に1つずつファクトを追加
- ファクトを追加
- showを再実行
- まだ充足可能であることを確認

ステップ3: 操作を追加
- 述語を定義
- `run`コマンドでテスト
- 動作が正しいことを確認

ステップ4: プロパティを検証
- アサーションを書く
- 小さなスコープでチェック
- 問題を修正、反復
- スコープを増やす
```

#### 3. 反例を理解する

プロパティが失敗したとき:

1. **グラフを注意深く見る**
2. **何が間違っているか特定**(どの制約が違反されているか?)
3. **パスをトレース**(どうやってこの状態に至ったか?)
4. **修正を決定**:
   - モデルエラー? → `.als`を修正
   - 仕様の隙間? → `spec.md`を更新
   - 有効なエッジケース? → 既知の制限として文書化

### ドキュメント

#### 1. プロパティを即座に更新

各検証セッション後、`properties.md`を更新:

- ステータスを変更(⬜ → ✅ または ❌)
- 検証日を追加
- 使用したスコープを追加
- メモを追加

#### 2. すべてのセッションを記録

すべての検証実行は`verification-log.md`に記録すべき:

- タイムスタンプ
- 結果(すべてのプロパティ)
- 反例(あれば)
- 取られたアクション

#### 3. ガイドを最新に保つ

`guide.md`を更新するタイミング:

- プロパティ定義が変更されたとき
- チームが新しいことを学んだとき
- 一般的な問題が発見されたとき

---

## よくある落とし穴

### 1. モデルの過度な制約

**問題**: ファクトを追加しすぎるとモデルが充足不可能になる。

```alloy
// ❌ 過度に制約 - 有効なインスタンスがない可能性
fact {
    all u: User | u.balance = 100
    all u: User | u.balance > 200  // 矛盾!
}
```

**解決策**: 制約を徐々に追加し、`run`コマンドで充足可能性を確認。

### 2. モデルの制約不足

**問題**: 制約が少なすぎると無効な状態を許す。

```alloy
// ❌ 残高に制約なし - マイナスになりうる!
sig User {
    balance: one Int
}

// 必要:
fact ValidBalance {
    all u: User | u.balance >= 0
}
```

**解決策**: *決して真であってはならない*ことを考え、それを防ぐファクトを書く。

### 3. 最初からスコープが大きすぎる

**問題**: 大きなスコープから開始すると時間を浪費し、デバッグが困難。

```alloy
// ❌ スコープ10から開始 - 時間がかかりすぎ、複雑な反例
check NoDoublePurchase for 10
```

**解決策**: 常に小さく開始(`for 3`)、徐々に増やす。

### 4. 反例を無視

**問題**: 理解せずに失敗を却下。

```
❌ 「チェックが失敗したが無視して進む」
```

**解決策**: すべての反例は何かを教えてくれます。進む前に理解してください。

### 5. 複数のモデルファイルを作成

**問題**: 1つのspecに対して複数の`.als`ファイルを作成。

```
❌ specs/001-feature/formal/
    ├── part1.als
    ├── part2.als
    └── part3.als
```

**解決策**: specごとに1つのモデルを保つ。複数のモデルが必要なら、specを分割。

### 6. formalディレクトリでSpec.mdを変更

**問題**: `formal/`内で仕様内容を複製または変更。

```
❌ specs/001-feature/formal/
    └── alternative-spec.md  # これをしない!
```

**解決策**: `spec.md`が唯一の真実の源。参照するが、複製しない。

### 7. 反復しない

**問題**: 最初のモデルが完璧であることを期待。

```
❌ モデル生成 → 検証 → すべて失敗 → 諦める
```

**解決策**: 形式検証は本質的に反復的です。数ラウンドを期待してください。

---

## チームガイドライン

### 役割と責任

#### 仕様作成者

- 明確性と完全性を持って`spec.md`を書く
- 形式検証が必要か判断
- 生成されたAlloyモデルの正確性をレビュー

#### リーダー（形式手法分かる人）

- `/speckit.formalize`を実行してモデルを生成
- 初回検証を実施
- 反例を解釈
- モデルの洗練を提案
- チームメンバーにAlloyの基礎を教える

#### チームメンバー

- 形式仕様をレビュー(Alloyを書く必要はない)
- `guide.md`に従って検証を実行
- 結果を報告
- 反例について質問を提起

### レビュープロセス

#### 形式仕様レビュー

`/speckit.formalize`の後:

1. **作成者がレビュー** `{feature}.als`:
   - `spec.md`の意図を捉えているか?
   - エンティティが正しくモデル化されているか?
   - 操作が正確に定義されているか?

2. **リーダー（形式手法分かる人）がレビュー**:
   - モデル構造は健全か?
   - 制約は適切か?
   - プロパティは検証可能か?

3. **チームがレビュー**(オプショナル):
   - `properties.md`は重要なシナリオをカバーしているか?
   - `guide.md`はチーム検証に明確か?

#### 検証結果レビュー

`/speckit.verify`の後:

1. **すべて合格**: 祝いましょう!文書化して進めます。
2. **一部失敗**:
   - チームとして反例をレビュー
   - 決定: モデル修正、spec更新、または既知の制限
   - 修正を実装して再検証
   - 解決または明示的に受け入れるまで進めない

### コミュニケーション

#### チームへの通知タイミング

**常に通知**:

- ❌ プロパティ失敗(重要な問題発見)
- ✅ すべてのプロパティ合格(実装準備完了)
- 🔄 反例に基づいてspec更新

**文書化場所**:

- Slack/Teamsチャンネル: {TEAM_CHANNEL}
- PR説明(Gitワークフローを使用している場合)
- 恒久記録として`verification-log.md`

#### エスカレーションパス

行き詰まったら:

1. `guide.md`のトラブルシューティングセクションをレビュー
2. リーダー（形式手法分かる人）に質問: {LEAD_NAME}
3. チームディスカッション: {TEAM_CHANNEL}
4. 外部リソース: Alloyコミュニティ、ドキュメント

---

## トラブルシューティング

### 問題: Alloy Analyzerが起動しない

**症状**: アプリケーションが起動しないまたは即座にクラッシュ

**解決策**:

1. Javaインストールを確認: `java -version`(Java 8以上が必要)
2. Alloy Analyzerを再ダウンロード
3. 異なるJavaバージョンを試す
4. システム要件を確認(Windows/Mac/Linux)

---

### 問題: モデルの検証に時間がかかりすぎる

**症状**: 分析が5分以上実行されても完了しない

**解決策**:

1. スコープを減らす: `for 5`の代わりに`for 3`を試す
2. ファクトを簡略化: 一時的にいくつかの制約をコメントアウト
3. モデルのパフォーマンス問題を確認(ネストされた量化子)
4. 段階的検証を使用(部分的に検証)

---

### 問題: 反例がないが、プロパティが間違っているように見える

**症状**: チェックが合格するが、失敗すると予想していた

**考えられる原因**:

1. **モデルの過度な制約**: ファクトが厳しすぎて反例を防いでいる
2. **スコープが小さすぎる**: より大きなスコープで反例が存在
3. **プロパティが弱すぎる**: アサーションが実際に思っていることをチェックしていない

**解決策**:

1. `run`コマンドを使ってインスタンスを生成し、妥当か確認
2. スコープを徐々に増やす
3. アサーションロジックを慎重にレビュー
4. 失敗すると予想するシナリオを「強制」する一時的なファクトを追加

---

### 問題: 反例が意味をなさない

**症状**: グラフが混乱した、または予期しない関係を示す

**解決策**:

1. シンプルに開始: 一度に1つのエンティティを見る
2. 関係性をトレース: 矢印を一歩ずつ追う
3. 属性値を確認: 数値/文字列を見る
4. 「Next」を使って代替反例を見る
5. 助けを求める: チームとスクリーンショットを共有

---

### 問題: Alloyモデルが理解できない

**症状**: 生成された`.als`ファイルが混乱する

**解決策**:

1. 最初にシグネチャに焦点を当てる(エンティティは何か?)
2. コメントを読む(モデルはよくコメントされているべき)
3. 最初は複雑な述語を無視
4. リーダー（形式手法分かる人）にウォークスルーを依頼
5. Alloyチュートリアルを参照: <http://alloytools.org/tutorials/online/>

---

### 問題: spec.mdにない何かをモデル化する必要がある

**症状**: モデルが自然言語仕様にない詳細を必要とする

**解決策**:

1. **まず**: 詳細が`spec.md`に暗黙的か確認
2. **本当に欠けている場合**: 詳細を追加するために`spec.md`を更新
3. **spec  には低レベルすぎる場合**: モデルのコメントに仮定を文書化
4. **不確かな場合**: 仕様作成者に明確化を求める

---

## 例

### 例1: 購入フロー(シンプル)

**シナリオ**: ユーザーが商品を購入、残高減少、在庫減少。

**Spec.md抜粋**:

```
ユーザーが「購入」をクリック。システムが残高 >= 価格 かつ 在庫 > 0 をチェック。
両方が真なら、残高から価格を引き、在庫を減らす。
```

**Alloyモデル**(`purchase.als`):

```alloy
sig User {
    balance: one Int
}

sig Product {
    price: one Int,
    stock: one Int
}

fact ValidValues {
    all u: User | u.balance >= 0
    all p: Product | p.price >= 0 and p.stock >= 0
}

pred canPurchase[u: User, p: Product] {
    u.balance >= p.price
    p.stock > 0
}

assert NoNegativeBalance {
    all u: User, p: Product |
        canPurchase[u, p] implies u.balance >= p.price
}

assert NoNegativeStock {
    all p: Product | p.stock >= 0
}

check NoNegativeBalance for 5
check NoNegativeStock for 5
```

**検証**:

- 両方のチェックがスコープ5で合格
- `properties.md`に文書化
- 実装の準備完了

---

### 例2: 並行性のある在庫(複雑)

**シナリオ**: 2人のユーザーが最後の商品を同時に購入しようとした場合、正しく処理されるべき。

**Spec.md抜粋**:

```
在庫 = 1で、2人のユーザーが同時に購入を試みたとき、
1人だけが成功すべき。在庫は決してマイナスにならないべき。
```

**初期Alloyモデル**(ナイーブ):

```alloy
sig User { balance: one Int }
sig Product { stock: one Int }

pred purchase[u: User, p: Product] {
    u.balance >= p.price
    p.stock > 0
    // 同期化がモデル化されていない
}

assert StockNeverNegative {
    all p: Product | p.stock >= 0
}

check StockNeverNegative for 5
```

**結果**: ❌ **失敗** - 反例が在庫 = -1を示す

**反例**:

```
Product: stock = 1
User1: 購入(在庫が0になる)
User2: 同時に購入(在庫が-1になる)
```

**修正**: 同期化制約を追加

```alloy
fact AtomicPurchase {
    // 同じ商品の2つの購入が同時に起こらない
    no disj p1, p2: Purchase |
        p1.product = p2.product and
        p1.timestamp = p2.timestamp
}

check StockNeverNegative for 5
```

**結果**: ✅ **合格**

**教訓**: 反例が並行性問題を明らかにした。モデルで修正、検証済み、今や確信を持って実装可能。

---

### 例3: 認証状態機械

**シナリオ**: ユーザーは保護されたリソースにアクセスする前にログインする必要がある。

**Spec.md抜粋**:

```
ユーザー状態: 匿名、認証済み、管理者
遷移: login (匿名 → 認証済み)、elevate (認証済み → 管理者)
認証済みまたは管理者のみが保護されたリソースにアクセス可能。
```

**Alloyモデル**:

```alloy
abstract sig UserState { }
one sig Anonymous, Authenticated, Admin extends UserState { }

sig User {
    state: one UserState
}

sig Resource {
    requiresAuth: one Bool
}

pred canAccess[u: User, r: Resource] {
    r.requiresAuth = True implies
        (u.state = Authenticated or u.state = Admin)
}

assert NoUnauthorizedAccess {
    all u: User, r: Resource |
        (canAccess[u, r] and r.requiresAuth = True) implies
            u.state != Anonymous
}

check NoUnauthorizedAccess for 5
```

**結果**: ✅ **合格**

**教訓**: 状態機械がAlloyで自然にモデル化された。複雑な認証ロジックを実装する前にプロパティが検証された。

---

## まとめ

### 重要なポイント

1. ✅ **1 spec = 1 Alloyモデル** - 明確なトレーサビリティ
2. ✅ **形式検証はオプショナル** - 戦略的に使用
3. ✅ **シンプルに始め、反復** - 最初から完璧を期待しない
4. ✅ **反例は価値がある** - エッジケースについて教えてくれる
5. ✅ **すべてを文書化** - properties.mdとverification-log.mdを更新
6. ✅ **チームコラボレーション** - リーダー（形式手法分かる人） + チームメンバー
7. ✅ **統合であって置き換えではない** - Spec Kitワークフローを補完

### クイックリファレンスカード

```
判断: 形式検証が必要?
  → 安全性が重要? 複雑な状態? 並行性? 
  → はい = 形式化、いいえ = スキップ

コマンド:
  /speckit.formalize → Alloyモデルを生成
  [手動Alloy Analyzer] → 検証を実行  
  /speckit.verify → 結果を文書化

ワークフロー:
  specify → plan → formalize → verify (反復) → tasks → implement

ファイル:
  formal/{feature}.als → specごとに単一モデル
  formal/properties.md → 検証チェックリスト
  formal/guide.md → チーム向け手順
  formal/verification-log.md → 履歴記録

検証:
  開始: スコープ3 (高速)
  標準: スコープ5 (推奨)
  徹底: スコープ7以上 (重要機能)

覚えておくこと:
  失敗 = 成功 (早期発見!)
  反復 = 通常 (一発ではない)
  文書化 = 必須 (チームと将来のため)
```

---

## 付録: 学習リソース

### Alloy

- **公式チュートリアル**: <http://alloytools.org/tutorials/online/>
- **書籍**: "Software Abstractions" by Daniel Jackson
- **例**: <http://alloytools.org/download/examples.html>

### 形式手法

- **TLA+ (比較用)**: learntla.com
- **Z記法**: spivey.oriel.ox.ac.uk/~mike/zrm/
- **形式手法Wiki**: wikipedia.org/wiki/Formal_methods

### コミュニティ

- **Alloy Discourse**: alloytools.discourse.group
- **Stack Overflow**: タグ "alloy"
- **GitHub**: github.com/AlloyTools

---

**このガイドに関する質問や提案は?**  
連絡先: {リーダー（形式手法分かる人）}  
ドキュメント場所: `.specify/docs/formal-methods-guide.md`
