# Spec Kit モデル検査統合ガイド

---

## 目次

1. [概要](#概要)
2. [核心原則](#核心原則)
3. [モデル検査を使うタイミング](#モデル検査を使うタイミング)
4. [ワークフロー統合](#ワークフロー統合)
5. [コマンドリファレンス](#コマンドリファレンス)
6. [ベストプラクティス](#ベストプラクティス)
7. [よくある落とし穴](#よくある落とし穴)
8. [チームガイドライン](#チームガイドライン)
9. [トラブルシューティング](#トラブルシューティング)
10. [例](#例)

---

## 概要

このガイドは、Alloyを使ったモデル検査をSpec Kitワークフローに統合する方法を説明します。モデル検査により、実装前に仕様について数学的にプロパティを証明し、設計上の欠陥を早期に発見できます。

### モデル検査とは?

モデル検査は、システムの状態空間を網羅的に探索して、システム設計が特定のプロパティを満たすことを検証します。「仕様のユニットテスト」と考えてください - コード記述前に設計が健全であることを検証します。

### なぜAlloy?

私たちは**Alloy**のみを使用します。理由:

- **Webアプリケーション向き**: ユーザー、商品、注文、関係性のモデリングが自然
- **視覚的フィードバック**: 反例がグラフとして表示(理解しやすい)
- **適度な学習曲線**: 一階述語論理 + 関係論理
- **実用的スコープ**: APIレベルとビジネスロジック検証に適している
- **単一ツールの習得**: 多数のツールを浅く知るより、1つのツールを深く理解する方が良い

### 主な利点

- ✅ コーディング前に設計上の欠陥を発見
- ✅ 重要なプロパティを検証(二重決済なし、在庫整合性など)
- ✅ 本番バグを削減
- ✅ 複雑なロジックへのチームの信頼を構築
- ✅ システム保証を文書化

---

## 核心原則

### 1. 1つの技術設計 = 1つのAlloyモデル

**ルール**: 各仕様ディレクトリは**ちょうど1つ**の`.als`ファイルを持つべきです。

```
✅ 正しい:
specs/001-purchase-flow/
├── spec.md
├── plan.md
└── formal/
    └── purchase.als          # 単一モデルファイル

❌ 間違い:
specs/001-purchase-flow/
└── formal/
    ├── purchase.als
    ├── inventory.als          # 複数モデル = 技術設計が大きすぎる
    └── payment.als
```

**理由は?**

- 明確なトレーサビリティを維持(plan.md ↔ purchase.als)
- Alloyは単一ファイルの世界モデル用に設計されている
- レビューとメンテナンスが簡略化
- 技術設計が大きすぎる場合のシグナルとして機能

**複数モデルが必要に見えたら:**

1. **まず**、`plan.md`を見直す - 複数の独立した機能をカバーしているか?
2. **もしそうなら**、仕様を別々の機能に分割
3. **もしそうでなければ**、ドメインが本質的に複雑 - なぜ1つのモデルで許容されるか文書化

### 2. モデル検査はオプショナルかつ補完的

**ルール**: モデル検査は標準Spec Kitワークフローをブロックまたは置き換えません。

- `spec.md`は自然言語での真実の源のまま
- モデル検査は重要な機能に対する追加の確信を提供
- チームはどの機能にモデル検査が必要か選択できる
- `formal/`ディレクトリは自己完結かつ独立

### 3. 既存ファイルの変更なし

**ルール**: モデル検査ツールは`spec.md`、`plan.md`、`tasks.md`、その他既存のSpec Kitファイルを変更しません。

すべてのモデル検査成果物は`formal/`サブディレクトリ内に存在:

```
specs/{FEATURE_NAME}/
├── spec.md                   # ✅ 当リポジトリのコマンドにより変更されない
├── plan.md                   # ✅ 当リポジトリのコマンドにより変更されない
├── tasks.md                  # ✅ 当リポジトリのコマンドにより変更されない
└── formal/                   # ✅ すべての作業はここに隔離
    ├── {feature}.als
    ├── properties.md
    └── verification-log.md
```

### 4. シンプルに始め、反復する

**ルール**: 基本的なモデルと小さなスコープから始め、反復的に洗練します。

**初回検証:**

- シンプルなドメインモデル(コアエンティティのみ)
- 基本プロパティ(明白な不変条件)
- 小さなスコープ(`for 3`)
- 高速フィードバックループ

**初回成功後:**

- 徐々に複雑さを追加
- スコープを増やす(`for 5`、`for 7`)
- より洗練されたプロパティを追加
- 反例に基づいて洗練

---

## モデル検査を使うタイミング

### 推奨される場合

✅ **金融操作**

- 決済処理
- 返金とキャンセル
- 残高計算
- トランザクションログ

✅ **在庫管理**

- 在庫整合性
- 並行購入処理
- 予約システム
- 在庫レベル制約

✅ **認証と認可**

- 権限チェック
- ロールベースアクセス制御
- セッション管理
- 認証フローでの状態遷移

✅ **複雑な状態機械**

- 注文ステータスワークフロー(保留中→支払済→発送済)
- ユーザー登録フロー
- ロールバック付き複数ステッププロセス

✅ **データ整合性要件**

- 参照整合性
- 一意性制約
- 関係性の濃度
- ビジネスルールの強制

### 推奨されない場合

❌ **単純なCRUD操作**

- 複雑なロジックのない基本的な作成、読み取り、更新、削除
- 些細な検証

❌ **UI/プレゼンテーションロジック**

- 表示フォーマット
- ビューレンダリング
- クライアント側のみの機能

❌ **パフォーマンス最適化**

- キャッシング戦略
- クエリ最適化
- 負荷分散

❌ **外部サービス統合**

- サードパーティAPI呼び出し(外部システムをモデル化できない)
- ネットワーク信頼性の問題

### 判断フレームワーク

以下の質問に答えてください:

1. **この機能は安全性が重要か?**
   (誤動作が金銭的損失、データ破損、セキュリティ侵害を引き起こす)
   → **はい** = モデル検査を使用

2. **複雑な状態遷移があるか?**
   (複数の状態、複雑な遷移ルール)
   → **はい** = モデル検査を使用

3. **微妙な並行性の問題があるか?**
   (複数のユーザー/プロセスが共有リソースにアクセス)
   → **はい** = モデル検査を使用

4. **ビジネスロジックが非自明か?**
   (複雑なルール、エッジケース、相互に関連した制約)
   → **はい** = モデル検査を使用

5. **短命またはクイックプロトタイプか?**
   → **いいえ** = モデル検査をスキップ(コストに見合わない)

---

## ワークフロー統合

### 標準Spec Kitワークフロー

```
1. /speckit.constitution  → プロジェクト原則を定義
2. /speckit.specify       → 自然言語仕様を作成
3. /speckit.plan          → 技術設計を生成
4. /speckit.tasks         → 実装タスクに分解
5. [実装]                 → コードを書く
```

### モデル検査を含む拡張ワークフロー

```
1. /speckit.constitution  → プロジェクト原則を定義
2. /speckit.specify       → 自然言語仕様を作成
3. /speckit.plan          → 技術設計を生成

   [判断ポイント: この機能はモデル検査が必要か?]

   もし必要なら:
   4a. /speckit.modelcheck.formalize → Alloyモデルを生成
   4b. /speckit.modelcheck.verify   → 検証実行＆結果文書化（自動）
   4c. [反復] 修正       → 失敗があれば、修正して再検証

   もし不要なら:
   4. [モデル検査をスキップ]

5. /speckit.tasks         → 実装タスクに分解
6. [実装]                 → 設計への確信を持ってコードを書く
```

### 典型的な反復パターン

モデル検査を必要とする機能の場合:

```
反復1:
- /speckit.modelcheck.formalize → 初期モデルを生成
- /speckit.modelcheck.verify    → 自動検証（スコープ3）
- ❌ 失敗発見                   → 反例をレビュー
- モデルを修正                  → .alsファイルを更新
- /speckit.modelcheck.verify    → 再検証

反復2:
- ✅ スコープ3ですべて合格
- alsファイルのスコープを5に変更 → より徹底的に検証
- /speckit.modelcheck.verify        → 再検証
- ❌ 新しい失敗                      → エッジケース発見
- spec.mdを更新                     → 要件を明確化
- /speckit.modelcheck.formalize     → モデルを再生成
- /speckit.modelcheck.verify        → 再検証

反復3:
- ✅ スコープ5ですべて合格
- 結果は自動で文書化済み
- /speckit.tasksへ進む
```

**重要な洞察**: 反復を期待してください。失敗を発見することが成功です - 早期に問題を捉えたということです!

---

## コマンドリファレンス

### `/speckit.modelcheck.formalize`

**目的**: `plan.md`等の技術設計からAlloyモデルを生成

**使い方**:

```
/speckit.modelcheck.formalize
```

**実行内容**:

1. `plan.md`、`data-model.md`、`contracts/`を読み込む（技術設計 = HOW）
2. エンティティ、関係性、操作を特定
3. `formal/{feature}.als`(Alloyモデル)を生成
4. `formal/properties.md`(検証チェックリスト)を生成

**出力ファイル**:

- `specs/{FEATURE_NAME}/formal/{feature}.als`
- `specs/{FEATURE_NAME}/formal/properties.md`

**使用タイミング**:

- `/speckit.specify`と`/speckit.plan`が完了した後
- モデル検査が必要と判断した時
- 実装開始前

**ヒント**:

- `plan.md`が完全でレビュー済みであることを確認
- 生成されたモデルの正確性をレビュー
- モデルが意図を捉えていなければ反復を躊躇しない

---

### `/speckit.modelcheck.verify`

**目的**: Alloyモデルの検証を実行し、結果を文書化

**使い方**:

```
/speckit.modelcheck.verify
```

**実行内容**:

1. Alloyモデル(`.als`ファイル)を自動検出
2. verify.shを**自動実行**してDocker経由で検証
3. 検証出力を解析（合格/不合格、反例など）
4. `formal/properties.md`を合格/不合格ステータスで更新
5. `formal/verification-log.md`にセッション詳細を追記
6. 失敗したプロパティに対する修正案を提案

**前提条件**:

- `formal/{feature}.als`が存在する(`/speckit.modelcheck.formalize`を先に実行)
- Docker環境が起動済み
- verify.shが実行可能な状態

**ワークフロー**:

1. コマンドがAlloyモデルを自動検出
2. コマンドがverify.shを**自動実行**（手動実行不要）
3. 出力を解析して結果を抽出
4. properties.md、verification-log.mdを更新
5. 失敗に対する修正を提案

**使用タイミング**:

- `/speckit.modelcheck.formalize`でモデル生成した後
- モデル修正後の再検証時
- チームに検証ステータスを更新するため

**ヒント**:

- タイムアウト指定: `/speckit.modelcheck.verify timeout 300` のように入力
- スコープはalsファイル内で指定（例: `check PropertyName for 7 but 8 Int`）
- 失敗した場合は反例を分析し、モデルを修正して再実行
- 各検証反復後にこれを使用

---

## ベストプラクティス

### モデル開発

#### 1. ドメインモデルから始める

```alloy
// 最初にエンティティを定義
sig User { }
sig Product { }
sig Order { }

// 徐々に属性を追加
sig User {
    email: one String,
    balance: one Int
}
```

#### 2. 制約を段階的に追加

```alloy
// 基本的なファクトから開始
fact ValidBalance {
    all u: User | u.balance >= 0
}

// 必要に応じてさらに追加
fact UniqueEmails {
    all disj u1, u2: User | u1.email != u2.email
}
```

#### 3. 述語をシンプルに保つ

```alloy
// ✅ 良い: シンプルで焦点を絞った述語
pred canPurchase[u: User, p: Product] {
    u.balance >= p.price
    p.stock > 0
}

// ❌ 悪い: 複雑すぎて検証が困難
pred purchase[u: User, p: Product, o: Order, ...] {
    // 50行の複雑なロジック
}
```

#### 4. 明確なアサーションを書く

```alloy
// ✅ 良い: 何を検証しているか明確
assert NoNegativeBalance {
    all u: User | u.balance >= 0
}

// ❌ 悪い: 意図が不明確
assert UserProperty {
    all u: User | some condition
}
```

### 検証戦略

#### 1. 適切なスコープを使用

| スコープ     | 用途                           | 時間       | 確信度   |
| ------------ | ------------------------------ | ---------- | -------- |
| `for 3`      | 初回テスト、高速フィードバック | 数秒       | 低       |
| `for 5`      | 標準検証                       | 数秒〜数分 | 中       |
| `for 7`      | 徹底的な検証                   | 数分       | 高       |
| `for 10以上` | 重要機能のみ                   | 遅い可能性 | 非常に高 |

**推奨**: `for 3`から開始、`for 5`で検証、必要な場合のみ増加。

#### 2. 段階的に検証

```
ステップ1: 基本構造
- シグネチャを定義
- `pred show { }` for 3 を実行
- インスタンスが妥当であることを確認

ステップ2: 一度に1つずつファクトを追加
- ファクトを追加
- showを再実行
- まだ充足可能であることを確認

ステップ3: 操作を追加
- 述語を定義
- `run`コマンドでテスト
- 動作が正しいことを確認

ステップ4: プロパティを検証
- アサーションを書く
- 小さなスコープでチェック
- 問題を修正、反復
- スコープを増やす
```

#### 3. 反例を理解する

プロパティが失敗したとき、検証出力に反例情報が表示されます:

```text
=== COUNTEREXAMPLE: PropertyName ===

[Assertion]
check PropertyName for 5 but 8 Int

[Skolem Variables]
$PropertyName_o = Order$0

[Instance Data]
Order$0:
  field: value
```

**解釈手順**:

1. **Skolem変数を確認**: `$PropertyName_o = Order$0` はアサーションを違反するインスタンスを示す
2. **alsファイルのassertを参照**: 対応するassert文を読み、論理構造を理解
3. **違反の意味を分析**: Skolemが存在 = 前提条件は満たすが不変条件に違反
4. **Instance Dataが空の場合**: Skolem変数 + モデル定義から具体例を推測

**修正を決定**:
- モデルエラー? → `.als`を修正
- 仕様の隙間? → `spec.md`を更新
- 有効なエッジケース? → 既知の制限として文書化

### ドキュメント

#### 1. プロパティを即座に更新

各検証セッション後、`properties.md`を更新:

- ステータスを変更(⬜ → ✅ または ❌)
- 検証日を追加
- 使用したスコープを追加
- メモを追加

#### 2. すべてのセッションを記録

すべての検証実行は`verification-log.md`に記録すべき:

- タイムスタンプ
- 結果(すべてのプロパティ)
- 反例(あれば)
- 取られたアクション

---

## よくある落とし穴

### 1. モデルの過度な制約

**問題**: ファクトを追加しすぎるとモデルが充足不可能になる。

```alloy
// ❌ 過度に制約 - 有効なインスタンスがない可能性
fact {
    all u: User | u.balance = 100
    all u: User | u.balance > 200  // 矛盾!
}
```

**解決策**: 制約を徐々に追加し、`run`コマンドで充足可能性を確認。

### 2. モデルの制約不足

**問題**: 制約が少なすぎると無効な状態を許す。

```alloy
// ❌ 残高に制約なし - マイナスになりうる!
sig User {
    balance: one Int
}

// 必要:
fact ValidBalance {
    all u: User | u.balance >= 0
}
```

**解決策**: *決して真であってはならない*ことを考え、それを防ぐファクトを書く。

### 3. 最初からスコープが大きすぎる

**問題**: 大きなスコープから開始すると時間を浪費し、デバッグが困難。

```alloy
// ❌ スコープ10から開始 - 時間がかかりすぎ、複雑な反例
check NoDoublePurchase for 10
```

**解決策**: 常に小さく開始(`for 3`)、徐々に増やす。

### 4. 反例を無視

**問題**: 理解せずに失敗を却下。

```
❌ 「チェックが失敗したが無視して進む」
```

**解決策**: すべての反例は何かを教えてくれます。進む前に理解してください。

### 5. 複数のモデルファイルを作成

**問題**: 1つのspecに対して複数の`.als`ファイルを作成。

```
❌ specs/001-feature/formal/
    ├── part1.als
    ├── part2.als
    └── part3.als
```

**解決策**: specごとに1つのモデルを保つ。複数のモデルが必要なら、specを分割。

### 6. formalディレクトリでSpec.mdを変更

**問題**: `formal/`内で仕様内容を複製または変更。

```
❌ specs/001-feature/formal/
    └── alternative-spec.md  # これをしない!
```

**解決策**: `spec.md`が唯一の真実の源。参照するが、複製しない。

### 7. 反復しない

**問題**: 最初のモデルが完璧であることを期待。

```
❌ モデル生成 → 検証 → すべて失敗 → 諦める
```

**解決策**: 形式検証は本質的に反復的です。数ラウンドを期待してください。

---

## チームガイドライン

### 役割と責任

#### 仕様作成者

- 明確性と完全性を持って`spec.md`を書く
- モデル検査が必要か判断
- 生成されたAlloyモデルの正確性をレビュー

#### リーダー（モデル検査分かる人）

- `/speckit.modelcheck.formalize`を実行してモデルを生成
- 初回検証を実施
- 反例を解釈
- モデルの洗練を提案
- チームメンバーにAlloyの基礎を教える

#### チームメンバー

- Alloyモデルをレビュー(Alloyを書く必要はない)
- `verify.sh`を使って検証を実行
- 結果を報告
- 反例について質問を提起

### レビュープロセス

#### Alloyモデルレビュー

`/speckit.modelcheck.formalize`の後:

1. **作成者がレビュー** `{feature}.als`:
   - `spec.md`の意図を捉えているか?
   - エンティティが正しくモデル化されているか?
   - 操作が正確に定義されているか?

2. **リーダー（モデル検査分かる人）がレビュー**:
   - モデル構造は健全か?
   - 制約は適切か?
   - プロパティは検証可能か?

3. **チームがレビュー**(オプショナル):
   - `properties.md`は重要なシナリオをカバーしているか?

#### 検証結果レビュー

`/speckit.modelcheck.verify`の後:

1. **すべて合格**: 祝いましょう!文書化して進めます。
2. **一部失敗**:
   - チームとして反例をレビュー
   - 決定: モデル修正、spec更新、または既知の制限
   - 修正を実装して再検証
   - 解決または明示的に受け入れるまで進めない

### コミュニケーション

#### チームへの通知タイミング

**常に通知**:

- ❌ プロパティ失敗(重要な問題発見)
- ✅ すべてのプロパティ合格(実装準備完了)
- 🔄 反例に基づいてspec更新

**文書化場所**:

- Slack/Teamsチャンネル: {TEAM_CHANNEL}
- PR説明(Gitワークフローを使用している場合)
- 恒久記録として`verification-log.md`

#### エスカレーションパス

行き詰まったら:

1. このドキュメントのトラブルシューティングセクションをレビュー
2. リーダー（モデル検査分かる人）に質問: {LEAD_NAME}
3. チームディスカッション: {TEAM_CHANNEL}
4. 外部リソース: Alloyコミュニティ、ドキュメント

---

## トラブルシューティング

### 問題: Alloy Analyzerが起動しない

**症状**: アプリケーションが起動しないまたは即座にクラッシュ

**解決策**:

1. Javaインストールを確認: `java -version`(Java 8以上が必要)
2. Alloy Analyzerを再ダウンロード
3. 異なるJavaバージョンを試す
4. システム要件を確認(Windows/Mac/Linux)

---

### 問題: モデルの検証に時間がかかりすぎる

**症状**: 分析が5分以上実行されても完了しない

**解決策**:

1. スコープを減らす: `for 5`の代わりに`for 3`を試す
2. ファクトを簡略化: 一時的にいくつかの制約をコメントアウト
3. モデルのパフォーマンス問題を確認(ネストされた量化子)
4. 段階的検証を使用(部分的に検証)

---

### 問題: 反例がないが、プロパティが間違っているように見える

**症状**: チェックが合格するが、失敗すると予想していた

**考えられる原因**:

1. **モデルの過度な制約**: ファクトが厳しすぎて反例を防いでいる
2. **スコープが小さすぎる**: より大きなスコープで反例が存在
3. **プロパティが弱すぎる**: アサーションが実際に思っていることをチェックしていない

**解決策**:

1. `run`コマンドを使ってインスタンスを生成し、妥当か確認
2. スコープを徐々に増やす
3. アサーションロジックを慎重にレビュー
4. 失敗すると予想するシナリオを「強制」する一時的なファクトを追加

---

### 問題: 反例が意味をなさない

**症状**: グラフが混乱した、または予期しない関係を示す

**解決策**:

1. シンプルに開始: 一度に1つのエンティティを見る
2. 関係性をトレース: 矢印を一歩ずつ追う
3. 属性値を確認: 数値/文字列を見る
4. 「Next」を使って代替反例を見る
5. 助けを求める: チームとスクリーンショットを共有

---

### 問題: Alloyモデルが理解できない

**症状**: 生成された`.als`ファイルが混乱する

**解決策**:

1. 最初にシグネチャに焦点を当てる(エンティティは何か?)
2. コメントを読む(モデルはよくコメントされているべき)
3. 最初は複雑な述語を無視
4. リーダー（モデル検査分かる人）にウォークスルーを依頼
5. Alloyチュートリアルを参照: <http://alloytools.org/tutorials/online/>

---

### 問題: plan.mdにない何かをモデル化する必要がある

**症状**: モデルが技術設計にない詳細を必要とする

**解決策**:

1. **まず**: 詳細が`plan.md`や`data-model.md`に暗黙的か確認
2. **本当に欠けている場合**: 詳細を追加するために`plan.md`を更新
3. **plan.mdには低レベルすぎる場合**: モデルのコメントに仮定を文書化
4. **不確かな場合**: 技術設計者に明確化を求める

---

## 例

### 例1: 購入フロー(シンプル)

**シナリオ**: ユーザーが商品を購入、残高減少、在庫減少。

**Spec.md抜粋**:

```
ユーザーが「購入」をクリック。システムが残高 >= 価格 かつ 在庫 > 0 をチェック。
両方が真なら、残高から価格を引き、在庫を減らす。
```

**Alloyモデル**(`purchase.als`):

```alloy
sig User {
    balance: one Int
}

sig Product {
    price: one Int,
    stock: one Int
}

fact ValidValues {
    all u: User | u.balance >= 0
    all p: Product | p.price >= 0 and p.stock >= 0
}

pred canPurchase[u: User, p: Product] {
    u.balance >= p.price
    p.stock > 0
}

assert NoNegativeBalance {
    all u: User, p: Product |
        canPurchase[u, p] implies u.balance >= p.price
}

assert NoNegativeStock {
    all p: Product | p.stock >= 0
}

check NoNegativeBalance for 5
check NoNegativeStock for 5
```

**検証**:

- 両方のチェックがスコープ5で合格
- `properties.md`に文書化
- 実装の準備完了

---

### 例2: 並行性のある在庫(複雑)

**シナリオ**: 2人のユーザーが最後の商品を同時に購入しようとした場合、正しく処理されるべき。

**Spec.md抜粋**:

```
在庫 = 1で、2人のユーザーが同時に購入を試みたとき、
1人だけが成功すべき。在庫は決してマイナスにならないべき。
```

**初期Alloyモデル**(ナイーブ):

```alloy
sig User { balance: one Int }
sig Product { stock: one Int }

pred purchase[u: User, p: Product] {
    u.balance >= p.price
    p.stock > 0
    // 同期化がモデル化されていない
}

assert StockNeverNegative {
    all p: Product | p.stock >= 0
}

check StockNeverNegative for 5
```

**結果**: ❌ **失敗** - 反例が在庫 = -1を示す

**反例**:

```
Product: stock = 1
User1: 購入(在庫が0になる)
User2: 同時に購入(在庫が-1になる)
```

**修正**: 同期化制約を追加

```alloy
fact AtomicPurchase {
    // 同じ商品の2つの購入が同時に起こらない
    no disj p1, p2: Purchase |
        p1.product = p2.product and
        p1.timestamp = p2.timestamp
}

check StockNeverNegative for 5
```

**結果**: ✅ **合格**

**教訓**: 反例が並行性問題を明らかにした。モデルで修正、検証済み、今や確信を持って実装可能。

---

### 例3: 認証状態機械

**シナリオ**: ユーザーは保護されたリソースにアクセスする前にログインする必要がある。

**Spec.md抜粋**:

```
ユーザー状態: 匿名、認証済み、管理者
遷移: login (匿名 → 認証済み)、elevate (認証済み → 管理者)
認証済みまたは管理者のみが保護されたリソースにアクセス可能。
```

**Alloyモデル**:

```alloy
abstract sig UserState { }
one sig Anonymous, Authenticated, Admin extends UserState { }

sig User {
    state: one UserState
}

sig Resource {
    requiresAuth: one Bool
}

pred canAccess[u: User, r: Resource] {
    r.requiresAuth = True implies
        (u.state = Authenticated or u.state = Admin)
}

assert NoUnauthorizedAccess {
    all u: User, r: Resource |
        (canAccess[u, r] and r.requiresAuth = True) implies
            u.state != Anonymous
}

check NoUnauthorizedAccess for 5
```

**結果**: ✅ **合格**

**教訓**: 状態機械がAlloyで自然にモデル化された。複雑な認証ロジックを実装する前にプロパティが検証された。

---

## まとめ

### 重要なポイント

1. ✅ **1 spec = 1 Alloyモデル** - 明確なトレーサビリティ
2. ✅ **モデル検査はオプショナル** - 戦略的に使用
3. ✅ **シンプルに始め、反復** - 最初から完璧を期待しない
4. ✅ **反例は価値がある** - エッジケースについて教えてくれる
5. ✅ **すべてを文書化** - properties.mdとverification-log.mdを更新
6. ✅ **チームコラボレーション** - リーダー（モデル検査分かる人） + チームメンバー
7. ✅ **統合であって置き換えではない** - Spec Kitワークフローを補完

### クイックリファレンスカード

```
判断: モデル検査が必要?
  → 安全性が重要? 複雑な状態? 並行性?
  → はい = モデル検査、いいえ = スキップ

コマンド:
  /speckit.modelcheck.formalize → Alloyモデルを生成
  /speckit.modelcheck.verify    → 検証実行＆結果文書化（自動）

ワークフロー:
  specify → plan → modelcheck.formalize → modelcheck.verify (反復) → tasks → implement

ファイル:
  formal/{feature}.als → specごとに単一モデル
  formal/properties.md → 検証チェックリスト
  formal/verification-log.md → 履歴記録

検証:
  スコープはalsファイル内で指定 (例: check P for 5 but 8 Int)
  開始: スコープ3 (高速)
  標準: スコープ5 (推奨)
  徹底: スコープ7以上 (重要機能)

覚えておくこと:
  失敗 = 成功 (早期発見!)
  反復 = 通常 (一発ではない)
  文書化 = 自動 (verify実行時に更新)
```

## FAQ

**Q: Alloyを学ぶ必要がありますか?**
A: チームメンバーは深いAlloy知識なしでverify.shを使って検証できます。リーダー（モデル検査分かる人）はAlloyの基礎を学ぶべきです。

**Q: すべての機能で必須ですか?**
A: いいえ!安全性が重要な機能のみで使用してください。ほとんどの機能はスキップできます。

**Q: モデル検査で問題が見つかったら?**
A: それが目標です!コーディング前に設計を修正します。本番バグより安価です。

**Q: TLA+など他のツールは使えますか?**
A: この拡張はシンプルさのためAlloy専用です。1つのツールを習得する方が、複数のツールを浅く知るよりも優れています。

**Q: モデル検査の専門家がいない場合は?**
A: [Alloyチュートリアル](http://alloytools.org/tutorials/online/)から始めてください。シンプルなモデルから開始。実践で学びましょう。

**Q: 開発が遅くなりませんか?**
A: 重要な機能では、後期段階の設計変更を防ぐことで全体的な納期を早めます。

**Q: 検証にどれくらいかかりますか?**
A: モデル生成: 2-5分。検証実行: 数秒〜数分。失敗の反復: 状況次第。初回の合計: 30-60分。経験とともに高速化。

**Q: プロパティが合格しない場合は?**
A: 設計に実際の問題がある(見つけて良かった!)、またはプロパティが厳しすぎる(洗練する)。時にはプロパティが検証不可能と分かること自体がシステムについての学びになります。

---

## 付録: 学習リソース

### Alloy

- **公式チュートリアル**: <http://alloytools.org/tutorials/online/>
- **書籍**: "Software Abstractions" by Daniel Jackson
- **例**: <http://alloytools.org/download/examples.html>

### モデル検査

- **TLA+ (比較用)**: learntla.com
- **モデル検査Wiki**: wikipedia.org/wiki/Model_checking

### コミュニティ

- **Alloy Discourse**: alloytools.discourse.group
- **Stack Overflow**: タグ "alloy"
- **GitHub**: github.com/AlloyTools
